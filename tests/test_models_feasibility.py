"""Tests for Pydantic feasibility schemas — MVP-10.

Covers:
- ConstraintType enum values
- Constraint construction and validation
- ConstraintSet versioning (next_version)
- TimeWindow validation
- FeasibilityResult immutability and gap sign convention
- BindingConstraint / EnablerRecommendation construction
- ConfidenceSummary bounds
- Reuse of existing ConstraintConfidence enum
- Solver metadata fields
- Satellite coefficients hash
"""

from uuid import uuid4

import pytest

from src.models.common import ConstraintConfidence
from src.models.feasibility import (
    BindingConstraint,
    ConfidenceSummary,
    Constraint,
    ConstraintSet,
    ConstraintType,
    EnablerRecommendation,
    FeasibilityResult,
    TimeWindow,
)


class TestConstraintTypeEnum:
    def test_all_values_present(self):
        values = {e.value for e in ConstraintType}
        assert values == {
            "CAPACITY_CAP",
            "RAMP_RATE",
            "LABOR_AVAILABILITY",
            "IMPORT_BOTTLENECK",
            "BUDGET_CEILING",
        }

    def test_is_str_enum(self):
        assert ConstraintType.CAPACITY_CAP == "CAPACITY_CAP"


class TestTimeWindow:
    def test_valid_construction(self):
        tw = TimeWindow(start_year=2025, end_year=2030)
        assert tw.start_year == 2025
        assert tw.end_year == 2030

    def test_end_before_start_raises(self):
        with pytest.raises(ValueError, match="end_year"):
            TimeWindow(start_year=2030, end_year=2025)

    def test_same_year_valid(self):
        tw = TimeWindow(start_year=2025, end_year=2025)
        assert tw.start_year == tw.end_year


class TestConstraint:
    def test_valid_construction(self):
        c = Constraint(
            constraint_type=ConstraintType.CAPACITY_CAP,
            applies_to="SEC01",
            value=1_000_000.0,
            unit="SAR",
            confidence=ConstraintConfidence.HARD,
        )
        assert c.constraint_type == ConstraintType.CAPACITY_CAP
        assert c.applies_to == "SEC01"
        assert c.value == 1_000_000.0
        assert c.confidence == ConstraintConfidence.HARD

    def test_uses_existing_constraint_confidence_enum(self):
        """Must reuse ConstraintConfidence from common.py, not a new enum."""
        c = Constraint(
            constraint_type=ConstraintType.LABOR_AVAILABILITY,
            applies_to="all",
            value=50000,
            unit="jobs",
            confidence=ConstraintConfidence.ESTIMATED,
        )
        assert isinstance(c.confidence, ConstraintConfidence)

    def test_constraint_id_autogenerated(self):
        c = Constraint(
            constraint_type=ConstraintType.BUDGET_CEILING,
            applies_to="all",
            value=5_000_000.0,
            unit="SAR",
            confidence=ConstraintConfidence.ASSUMED,
        )
        assert c.constraint_id is not None

    def test_applies_to_all(self):
        c = Constraint(
            constraint_type=ConstraintType.BUDGET_CEILING,
            applies_to="all",
            value=10_000_000.0,
            unit="SAR",
            confidence=ConstraintConfidence.HARD,
        )
        assert c.applies_to == "all"

    def test_with_time_window(self):
        c = Constraint(
            constraint_type=ConstraintType.RAMP_RATE,
            applies_to="SEC01",
            value=0.15,
            unit="pct",
            confidence=ConstraintConfidence.ESTIMATED,
            time_window=TimeWindow(start_year=2025, end_year=2030),
        )
        assert c.time_window is not None
        assert c.time_window.start_year == 2025

    def test_with_evidence_refs(self):
        ref_id = uuid4()
        c = Constraint(
            constraint_type=ConstraintType.IMPORT_BOTTLENECK,
            applies_to="SEC02",
            value=500_000.0,
            unit="SAR",
            confidence=ConstraintConfidence.HARD,
            evidence_refs=[ref_id],
            notes="Based on port capacity data.",
        )
        assert len(c.evidence_refs) == 1
        assert c.notes == "Based on port capacity data."


class TestConstraintSet:
    def test_valid_construction(self):
        cs = ConstraintSet(
            workspace_id=uuid4(),
            model_version_id=uuid4(),
            name="2026 Mega-Project Constraints",
            constraints=[
                Constraint(
                    constraint_type=ConstraintType.CAPACITY_CAP,
                    applies_to="SEC01",
                    value=500_000.0,
                    unit="SAR",
                    confidence=ConstraintConfidence.HARD,
                ),
            ],
        )
        assert cs.version == 1
        assert len(cs.constraints) == 1

    def test_default_version_is_1(self):
        cs = ConstraintSet(
            workspace_id=uuid4(),
            model_version_id=uuid4(),
            name="Test",
        )
        assert cs.version == 1

    def test_next_version_increments(self):
        cs = ConstraintSet(
            workspace_id=uuid4(),
            model_version_id=uuid4(),
            name="Test",
        )
        v2 = cs.next_version()
        assert v2.version == 2
        assert v2.constraint_set_id == cs.constraint_set_id
        assert v2.workspace_id == cs.workspace_id

    def test_next_version_chain(self):
        cs = ConstraintSet(
            workspace_id=uuid4(),
            model_version_id=uuid4(),
            name="Test",
        )
        v3 = cs.next_version().next_version()
        assert v3.version == 3


class TestBindingConstraint:
    def test_valid_construction(self):
        bc = BindingConstraint(
            constraint_id=uuid4(),
            constraint_type=ConstraintType.CAPACITY_CAP,
            sector_code="SEC01",
            shadow_price=0.75,
            gap_to_feasible=50_000.0,
            recommendation="Expand production capacity in SEC01",
        )
        assert bc.shadow_price == 0.75
        assert bc.gap_to_feasible == 50_000.0


class TestEnablerRecommendation:
    def test_valid_construction(self):
        er = EnablerRecommendation(
            constraint_id=uuid4(),
            title="Expand port capacity",
            description="Increase throughput by 20%",
            policy_lever="Infrastructure investment",
            estimated_unlock_value=15_000.0,
            priority_rank=1,
        )
        assert er.priority_rank == 1
        assert er.estimated_unlock_value == 15_000.0

    def test_priority_rank_must_be_positive(self):
        with pytest.raises(ValueError):
            EnablerRecommendation(
                constraint_id=uuid4(),
                title="Test",
                policy_lever="Test",
                estimated_unlock_value=0.0,
                priority_rank=0,  # Invalid — must be >= 1
            )


class TestConfidenceSummary:
    def test_valid_construction(self):
        cs = ConfidenceSummary(
            hard_pct=0.6,
            estimated_pct=0.3,
            assumed_pct=0.1,
            total_constraints=10,
        )
        assert cs.hard_pct == 0.6
        assert cs.total_constraints == 10

    def test_percentages_must_be_01(self):
        with pytest.raises(ValueError):
            ConfidenceSummary(
                hard_pct=1.5,  # > 1.0
                estimated_pct=0.0,
                assumed_pct=0.0,
                total_constraints=1,
            )


class TestFeasibilityResult:
    def _make_result(self, **overrides):
        defaults = dict(
            unconstrained_run_id=uuid4(),
            constraint_set_id=uuid4(),
            constraint_set_version=1,
            feasible_delta_x={"SEC01": 80.0, "SEC02": 60.0},
            unconstrained_delta_x={"SEC01": 100.0, "SEC02": 60.0},
            gap_vs_unconstrained={"SEC01": 20.0, "SEC02": 0.0},
            total_feasible_output=140.0,
            total_unconstrained_output=160.0,
            total_gap=20.0,
            confidence_summary=ConfidenceSummary(
                hard_pct=0.5, estimated_pct=0.3, assumed_pct=0.2, total_constraints=3,
            ),
            satellite_coefficients_hash="abc123",
            solver_type="clipping",
            solver_version="1.0.0",
        )
        defaults.update(overrides)
        return FeasibilityResult(**defaults)

    def test_valid_construction(self):
        r = self._make_result()
        assert r.total_gap == 20.0
        assert r.solver_type == "clipping"

    def test_immutable(self):
        r = self._make_result()
        with pytest.raises(Exception):
            r.total_gap = 999

    def test_gap_sign_convention_positive(self):
        """gap = unconstrained - feasible, always >= 0."""
        r = self._make_result()
        for val in r.gap_vs_unconstrained.values():
            assert val >= 0.0

    def test_gap_sign_negative_raises(self):
        """Negative gap values violate the canonical convention."""
        with pytest.raises(ValueError, match="gap_vs_unconstrained"):
            self._make_result(
                gap_vs_unconstrained={"SEC01": -5.0, "SEC02": 0.0},
            )

    def test_total_gap_must_be_non_negative(self):
        with pytest.raises(ValueError, match="total_gap"):
            self._make_result(total_gap=-1.0)

    def test_satellite_coefficients_hash_present(self):
        r = self._make_result()
        assert r.satellite_coefficients_hash == "abc123"

    def test_solver_metadata_fields(self):
        r = self._make_result(
            solver_type="lp",
            solver_version="1.0.0",
            lp_status="optimal",
            fallback_used=False,
        )
        assert r.solver_type == "lp"
        assert r.lp_status == "optimal"
        assert r.fallback_used is False

    def test_default_solver_metadata(self):
        r = self._make_result()
        assert r.lp_status is None
        assert r.fallback_used is False

    def test_serialization_roundtrip(self):
        r = self._make_result()
        data = r.model_dump(mode="json")
        assert "feasibility_result_id" in data
        assert data["solver_type"] == "clipping"
        assert data["gap_vs_unconstrained"]["SEC01"] == 20.0
